<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Galaxy Background — Portfolio</title>
<style>
  :root{
    --bg-dark: #05060a;
    --accent-1: #6b5df5; /* purple */
    --accent-2: #3dd4ff; /* cyan */
    --overlay: rgba(200,200,200,0.06); /* subtle light grey for geometric pattern */
  }

  html,body{
    height:100%;
    margin:0;
    /*background: radial-gradient(1200px 600px at 10% 20%, rgba(107,93,245,0.08), transparent 6%),
                radial-gradient(1000px 500px at 90% 70%, rgba(61,212,255,0.06), transparent 6%),
                var(--bg-dark); */
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color:#eee;
  }

  /* Full viewport canvas container */
  .bg-wrap{
    position:fixed;
    inset:0;
    overflow:hidden;
    z-index:-1;
    background: radial-gradient(1200px 600px at 10% 20%, rgba(107,93,245,0.08), transparent 6%),
                radial-gradient(1000px 500px at 90% 70%, rgba(61,212,255,0.06), transparent 6%),
                var(--bg-dark); 
  }

  canvas{
    display:block;
    width:100vw;
    height:100vh;
  }

  /* Geometric overlay: SVG triangle grid */
  .overlay {
    position:fixed;
    inset:0;
    pointer-events:none;
    z-index:0;
    opacity:1;
    mix-blend-mode:normal;
  }

  /* Subtle vignette */
  .vignette {
    position:fixed;
    inset:0;
    background: radial-gradient(60% 60% at 50% 50%, rgba(0,0,0,0) 0%, rgba(0,0,0,0.18) 80%);
    pointer-events:none;
    z-index:1;
  }

  /* content placeholder to show how to use it in a page */
  .content {
    position:relative;
    z-index:2;
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:40px;
  }

  .card {
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
    border:1px solid rgba(255,255,255,0.04);
    padding:32px;
    border-radius:14px;
    max-width:880px;
    width:100%;
    box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    backdrop-filter: blur(6px) saturate(120%);
  }

  h1 { margin: 0 0 8px 0; font-size: clamp(20px, 3.6vw, 36px); letter-spacing: -0.02em; }
  p { margin: 0; opacity: 0.9; line-height:1.45; }

  /* Reduced motion preference */
  @media (prefers-reduced-motion: reduce) {
    canvas { animation: none !important; }
  }
</style>
</head>
<body>
  <div class="bg-wrap" aria-hidden="true">
    <canvas id="starfield"></canvas>

    <!-- SVG triangle / geometric overlay (subtle light grey) -->
    <svg class="overlay" width="100%" height="100%" preserveAspectRatio="xMidYMid slice" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">
      <defs>
        <pattern id="triPattern" width="60" height="52" patternUnits="userSpaceOnUse">
          <!-- Hex/triangle style: draw triangle grid -->
          <g stroke="rgba(210,210,210,0.05)" stroke-width="1" fill="none">
            <path d="M0 26 L30 0 L60 26" />
            <path d="M0 26 L30 52 L60 26" />
            <path d="M30 0 L30 52" />
          </g>
        </pattern>
        <!-- a second, even subtler layer with larger spacing for depth -->
        <pattern id="triPattern2" width="180" height="156" patternUnits="userSpaceOnUse">
          <g stroke="rgba(210,210,210,0.06)" stroke-width="1" fill="none">
            <path d="M0 78 L90 0 L180 78" />
            <path d="M0 78 L90 156 L180 78" />
            <path d="M90 0 L90 156" />
          </g>
        </pattern>
      </defs>

      <!-- Apply two layers for subtle complexity -->
      <rect width="100%" height="100%" fill="url(#triPattern)" opacity="0.42"></rect>
      <rect width="100%" height="100%" fill="url(#triPattern2)" opacity="0.22"></rect>

      <!-- Center subtle cross-halo to add a focal point -->
      <radialGradient id="centerGlow" cx="50%" cy="35%" r="50%">
        <stop offset="0%" stop-color="rgba(255,255,255,0.03)" />
        <stop offset="100%" stop-color="rgba(255,255,255,0)" />
      </radialGradient>
      <rect width="100%" height="100%" fill="url(#centerGlow)"></rect>
    </svg>

    <div class="vignette" aria-hidden="true"></div>
  </div>

  <main class="content" role="main">
    <div class="card" aria-label="Landing card example">
      <h1>Michael Parenti — Website Background Ideas</h1>
      <p>Static portfolio background using HTML, CSS & Vanilla JS. This animated galaxy + geometric overlay is lightweight and GitHub Pages friendly.</p>
    </div>
  </main>

<script>
/*
  starfield.js — lightweight animated galaxy-like background
  - uses requestAnimationFrame
  - multiple depth layers (z), parallax on mouse move
  - respects prefers-reduced-motion
*/

(function () {
  const canvas = document.getElementById('starfield');
  const ctx = canvas.getContext('2d', { alpha: true });
  let width = 0, height = 0, dpr = 1;

  // configuration
  const config = {
    starCount: 220,        // overall number of "stars" (particles)
    layers: 3,             // depth layers for parallax
    baseSpeed: 0.02,       // base zoom speed
    nebulaCount: 3,        // soft cloud blobs
    shootingChance: 0.005, // chance per frame to spawn shooting star
  };

  // motion preference check
  const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // store particles
  let stars = [];
  let nebulae = [];
  let shootStars = [];
  const mouse = { x: 0, y: 0, tx: 0, ty: 0 };

  // initialize sizing
  function resize() {
    dpr = window.devicePixelRatio || 1;
    width = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    height = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    canvas.width = Math.round(width * dpr);
    canvas.height = Math.round(height * dpr);
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  // Star constructor
  function makeStar(i) {
    // depth layer assignment: 0 (near) ... layers-1 (far)
    const layer = Math.floor(Math.random() * config.layers);
    const z = (layer + 1) / config.layers; // deeper stars have larger z
    return {
      x: Math.random() * width,
      y: Math.random() * height,
      z: z,
      // size modulated by depth and randomness
      size: (Math.random() * 1.6 + 0.2) * (1.2 - z) * 1.6,
      baseAlpha: 0.6 * (1.1 - z),
      twinkle: Math.random() * Math.PI * 2,
      colorShift: Math.random(), // used to slightly shift color per star
      layer
    };
  }

  // Nebula constructor (soft blurred blobs)
  function makeNebula(i) {
    const w = width * (0.25 + Math.random() * 0.7);
    const h = height * (0.2 + Math.random() * 0.6);
    return {
      x: Math.random() * width,
      y: Math.random() * height,
      w, h,
      hue: 180 + Math.random() * 160,   // bluish-purple spectrum
      alpha: 0.06 + Math.random() * 0.08,
      speed: 0.02 + Math.random() * 0.04,
      angle: Math.random() * Math.PI * 2
    };
  }

  // Shooting star
  function spawnShootingStar() {
    const startX = Math.random() < 0.6 ? -50 : width + 50;
    const startY = Math.random() * height * 0.6;
    const vx = startX < 0 ? (1 + Math.random() * 8) : -(1 + Math.random() * 8);
    const vy = (0.5 - Math.random()) * 2;
    shootStars.push({
      x: startX,
      y: startY,
      vx, vy,
      life: 0,
      maxLife: 70 + Math.random() * 60,
      length: 40 + Math.random() * 90
    });
  }

  // init
  function init() {
    resize();
    stars = new Array(config.starCount).fill(0).map((_, i) => makeStar(i));
    nebulae = new Array(config.nebulaCount).fill(0).map((_, i) => makeNebula(i));
    shootStars = [];
    // mouse center by default
    mouse.x = width / 2;
    mouse.y = height / 2;
  }

  // handle pointer move for parallax
  window.addEventListener('pointermove', (e) => {
    mouse.tx = e.clientX;
    mouse.ty = e.clientY;
  });

  // smooth mouse follow
  function updateMouse() {
    // lerp
    mouse.x += (mouse.tx - mouse.x) * 0.08;
    mouse.y += (mouse.ty - mouse.y) * 0.08;
  }

  // draw glow star
  function drawStar(s, t) {
    const { x, y, size, baseAlpha, z, colorShift } = s;
    // twinkle
    const tw = Math.sin(s.twinkle + t * 0.002) * 0.4 + 0.6;
    const alpha = baseAlpha * tw;

    // color mix between purple and cyan slightly
    const r = 170 * (0.5 + 0.5 * colorShift);
    const g = 200 * (0.2 + 0.8 * (1 - colorShift));
    const b = 255 * (0.9 - 0.5 * colorShift);
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    // small outer glow
    const grad = ctx.createRadialGradient(x, y, 0, x, y, Math.max(8, size * 12));
    grad.addColorStop(0, `rgba(${r|0}, ${g|0}, ${b|0}, ${(alpha*0.45).toFixed(3)})`);
    grad.addColorStop(0.35, `rgba(${r|0}, ${g|0}, ${b|0}, ${(alpha*0.14).toFixed(3)})`);
    grad.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, Math.max(8, size * 12), 0, Math.PI*2);
    ctx.fill();

    // core
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,${(alpha*0.9).toFixed(3)})`;
    ctx.arc(x, y, Math.max(0.6, size * 0.9), 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // draw soft nebula
  function drawNebula(n, t) {
    // create radial gradient
    const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, Math.max(n.w, n.h));
    const hue = Math.floor(n.hue);
    const a = n.alpha;
    g.addColorStop(0, `hsla(${hue}, 80%, 60%, ${a})`);
    g.addColorStop(0.35, `hsla(${(hue+40)%360}, 70%, 45%, ${a*0.6})`);
    g.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(n.x, n.y, n.w, n.h, Math.sin(t * 0.0002 + n.angle) * 0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // draw shooting star (fast trail)
  function drawShooting(s) {
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    const grad = ctx.createLinearGradient(s.x, s.y, s.x - s.vx * s.length, s.y - s.vy * s.length);
    grad.addColorStop(0, 'rgba(255,255,255,0.95)');
    grad.addColorStop(0.6, 'rgba(255,240,220,0.65)');
    grad.addColorStop(1, 'rgba(255,240,220,0)');
    ctx.strokeStyle = grad;
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(s.x - s.vx * s.length, s.y - s.vy * s.length);
    ctx.stroke();
    ctx.restore();
  }

  // main render loop
  let lastT = performance.now();
  function frame(t) {
    const dt = t - lastT;
    lastT = t;

    if (!reduceMotion) updateMouse();

    ctx.clearRect(0,0,width,height);

    // move & draw nebulae (back-most layer)
    nebulae.forEach((n)=>{
      // slow drift influenced by time and subtle mouse offset
      n.x += Math.sin(t * 0.0001 + n.angle) * n.speed * 0.3;
      n.y += Math.cos(t * 0.00011 + n.angle) * n.speed * 0.22;
      // gentle wrap
      if (n.x < -n.w) n.x = width + n.w;
      if (n.x > width + n.w) n.x = -n.w;
      if (n.y < -n.h) n.y = height + n.h;
      if (n.y > height + n.h) n.y = -n.h;

      drawNebula(n, t);
    });

    // stars: update positions as subtle zooming
    for (let i=0;i<stars.length;i++){
      const s = stars[i];
      // depth-based movement: near layers move faster; parallax from mouse
      const depthFactor = 1.2 - s.z;
      const parX = ((mouse.x - width/2) / (width/2)) * 8 * (1 - s.z) * 0.8;
      const parY = ((mouse.y - height/2) / (height/2)) * 8 * (1 - s.z) * 0.8;

      // subtle radial drift to create depth feeling
      s.x += (Math.cos(t * 0.0003 + i) * 0.02 + parX * 0.01) * depthFactor;
      s.y += (Math.sin(t * 0.0004 + i) * 0.02 + parY * 0.01) * depthFactor;

      // zoom effect: small scaling around center
      const cx = width/2, cy = height/2;
      const dx = s.x - cx, dy = s.y - cy;
      s.x += dx * 0.00008 * depthFactor;
      s.y += dy * 0.00008 * depthFactor;

      // twinkle progress
      s.twinkle += 0.01 + 0.01 * (1 - s.z);

      // wrap edges
      if (s.x < -30) s.x = width + 30;
      if (s.x > width + 30) s.x = -30;
      if (s.y < -30) s.y = height + 30;
      if (s.y > height + 30) s.y = -30;

      drawStar(s, t);
    }

    // handle shooting stars
    if (!reduceMotion && Math.random() < config.shootingChance) {
      spawnShootingStar();
    }
    for (let i = shootStars.length - 1; i >= 0; i--) {
      const s = shootStars[i];
      s.x += s.vx;
      s.y += s.vy;
      s.life++;
      drawShooting(s);
      if (s.life > s.maxLife || s.x < -200 || s.x > width + 200 || s.y < -200 || s.y > height + 200) {
        shootStars.splice(i, 1);
      }
    }

    // subtle overall glow layer (low alpha)
    // create a soft composite to give depth — painted as a rectangle with gradient
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = 0.06;
    const g = ctx.createLinearGradient(0,0,width,height);
    g.addColorStop(0, 'rgba(110,90,245,0.045)');
    g.addColorStop(0.5, 'rgba(60,210,255,0.02)');
    g.addColorStop(1, 'rgba(40,10,60,0.03)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,width,height);
    ctx.restore();

    // repeat
    requestAnimationFrame(frame);
  }

  // handle window resize
  window.addEventListener('resize', () => {
    resize();
    // reposition stars proportionally to new size
    stars.forEach(s => {
      s.x = Math.random() * width;
      s.y = Math.random() * height;
    });
    nebulae = nebulae.map(() => makeNebula());
  });

  // init then animate
  init();
  // Center mouse target on load
  mouse.tx = width/2;
  mouse.ty = height/2;
  requestAnimationFrame(frame);

  // expose control for debugging in the console if needed
  window._galaxy = {
    reset: init,
    spawnShootingStar
  };
})();
</script>
</body>
</html>
